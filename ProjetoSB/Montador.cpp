//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : ProjetoSB
//  @ File Name : Montador.cpp
//  @ Date : 09/01/2013
//  @ Author : Willian
//
//


#include "Montador.h"


Montador::Montador(CodigoIn *codigoIn, CodigoOut *codigoOut) {
	this->codigoIn = codigoIn;
	this->codigoOut = codigoOut;
}

void Montador::monta() throw (runtime_error) {
	primeiraPassagem();
	segundaPassagem();
}

void Montador::primeiraPassagem() throw (runtime_error) {
	string linha;
	list<string> tokens;
	//string label;
	int posicao_fim_label;
	Operacao predicado;
	ItemLabel temp_label;
	int PLC = 0;


	while((linha = codigoIn->pegaLinha()).compare("-FIM-")) {

		//Procura o fim de um label.
		posicao_fim_label = linha.find(":");

		//Caso  tenha label na string.
		if (posicao_fim_label != string::npos){

			temp_label.label = linha.substr(0,posicao_fim_label);
			temp_label.endereco = PLC;

			linha = linha.substr(posicao_fim_label+1, (linha.size()-posicao_fim_label) );
			cout << "LABEL IDENTIFICADO: " << temp_label.label << "   Endereço: " << temp_label.endereco << endl;
			listaLabels.push_back(temp_label);
		}

		cout << "Instrucao Lida: "<< linha << endl;
		if(!linha.empty()){
			// pega uma lista de tokens
			tokens = separaTokens(linha);

			// verifica o tipo de predicado
			predicado = pegaPredicado(tokens);

			listaInstrucoes.push_back(predicado);
			PLC += 4;
		}

	}

	//A lista de instrucoes ja esta montada. Sera usada na segunda passagem.
}

void Montador::segundaPassagem() throw (runtime_error) {
	Operacao aux;
	list<Operacao> temp_op;
	list<ItemLabel> temp_labels;
	//Contador de posicoes
	list<Operacao>::iterator it;
	it = listaInstrucoes.begin();
	temp_op = listaInstrucoes;

	while(!temp_op.empty()){
		aux = temp_op.front();
		if(aux.verifica_nome("j")){
			for(temp_labels = listaLabels; !temp_labels.empty(); temp_labels.pop_front()){
				//Procura o endereco do label na lista de labels
				if(aux.verifica_label(temp_labels.front().label)){
					aux = atualizar_endereco(temp_labels.front().endereco);
					listaInstrucoes.erase(it);
					listaInstrucoes.insert(it,aux);
				}
			}
		}
		temp_op.pop_front();
		it++;
	}
}

Operacao Montador::atualizar_endereco(int endereco){
	string tokens[]= {"j","\0"};
	list<string> mylist (tokens,tokens+2);
	return OperacaoJump(mylist,endereco);
}

list<string> Montador::separaTokens(string linha)throw (runtime_error) {

	// troca as virgulas por espaços em branco
	int virgula, numVirgulas = 0;
	while ((virgula = linha.find(',')) != string::npos) {
		linha.replace(virgula, 1," ");
		numVirgulas++;
	}

	// separa por espaço em branco
	istringstream linhaStream(linha);
	vector<string> tokens;
	copy(istream_iterator<string>(linhaStream),
				istream_iterator<string>(),
				back_inserter<vector<string> >(tokens));

	list<string> tokensSaida(tokens.begin(),tokens.end());
	ItemOperacao op = encontraOperacao(tokens[0]);

	list<string>::const_iterator i;
	cout << "Lista de Tokens Gerada: ";
	for( i = tokensSaida.begin(); i != tokensSaida.end(); ++i)
						cout << *i << " - ";
					cout << endl;


	list<string>	tokensSaidaValidado;
	tokensSaidaValidado = validaTokens(tokensSaida, numVirgulas);




	return tokensSaida;
}

Operacao Montador::pegaPredicado(list<string> tokens) throw (runtime_error) {
	ItemOperacao op = encontraOperacao(tokens.front());

	switch (op.tipo) {
	case FR:
		return OperacaoBinaria(tokens);
		//	case R:
		//		return OperacaoBinaria(tokens);
		//	case I:
	case J:
		return OperacaoJump(tokens,-1);
		//	case LABEL:
	default:
		throw runtime_error("Operação não identificada");
	}
}

list<string> Montador::validaTokens(list<string> listaTokens, int numVirgulas) throw (runtime_error) {

	ItemOperacao op = encontraOperacao(listaTokens.front());
	switch (op.tipo) {
		case FR:
			if (numVirgulas != 2)
				throw runtime_error("Problema no numero de virgulas " + numVirgulas);
			if (listaTokens.empty())
					throw runtime_error("Lista de tokens vazia - OperacaoBinaria");
			if (listaTokens.size() != 4){
					stringstream num;
					num << listaTokens.size();
					throw runtime_error("Operação binaria com numero errado de argumentos, esperava 4 mas tem " + num.str());
			}
			//Checa se os registradores sao validos
			//TODO

			break;
		//	case R:
		//	case I:
		case J:
			if (numVirgulas != 0)
					throw runtime_error("Problema no numero de virgulas " + numVirgulas);
			if (listaTokens.empty())
					throw runtime_error("Lista de tokens vazia - OperacaoBinaria");
			if (listaTokens.size() != 2){
					stringstream num;
					num << listaTokens.size();
					throw runtime_error("Operação binaria com numero errado de argumentos, esperava 2 mas tem " + num.str());
			}
			break;
		default:
			throw runtime_error("operação não identificada");
		}

	return listaTokens;
}
