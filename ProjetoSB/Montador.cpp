//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : ProjetoSB
//  @ File Name : Montador.cpp
//  @ Date : 09/01/2013
//  @ Author : Willian
//
//


#include "Montador.h"


Montador::Montador(CodigoIn *codigoIn, CodigoOut *codigoOut) {
	this->codigoIn = codigoIn;
	this->codigoOut = codigoOut;
}

void Montador::monta() throw (runtime_error) {
	primeiraPassagem();
	segundaPassagem();
}

void Montador::primeiraPassagem() throw (runtime_error) {
	string linha;
	list<string> tokens;
	//string label;
	int posicao_fim_label;
	Operacao predicado;
	ItemLabel temp_label;
	int PLC = 0;


	while((linha = codigoIn->pegaLinha()).compare("-FIM-")) {

		//Procura o fim de um label.
		posicao_fim_label = linha.find(":");

		//Caso  tenha label na string.
		if (posicao_fim_label != string::npos){

			temp_label.label = linha.substr(0,posicao_fim_label);
			temp_label.endereco = PLC;

			linha = linha.substr(posicao_fim_label+1, (linha.size()-posicao_fim_label) );
			cout << "LABEL IDENTIFICADO - " << temp_label.label << "Endereço - " << temp_label.endereco << "\n";
			codigoIn->Label.push_front(temp_label);
		}

		cout << "Instrucao Lida: "<< linha << endl;
		if(!linha.empty()){
			// pega uma lista de tokens
			tokens = separaTokens(linha);

			// verifica o tipo de predicado
			predicado = pegaPredicado(tokens);

			listaIntrucoes.push_back(predicado);
			PLC += 4;
		}

	}

	//A lista de instrucoes ja esta montada. Sera usada na segunda passagem.
}

void Montador::segundaPassagem() throw (runtime_error) {

}

list<string> Montador::separaTokens(string linha)throw (runtime_error) {

	// troca as virgulas por espaços em branco
	int virgula, numVirgulas = 0;
	while ((virgula = linha.find(',')) != string::npos) {
		linha.replace(virgula, 1," ");
		numVirgulas++;
	}

	// separa por espaço em branco
	istringstream linhaStream(linha);
	vector<string> tokens;
	copy(istream_iterator<string>(linhaStream),
				istream_iterator<string>(),
				back_inserter<vector<string> >(tokens));

	list<string> tokensSaida(tokens.begin(),tokens.end());
	ItemOperacao op = encontraOperacao(tokens[0]);

	list<string>::const_iterator i;
	cout << "Lista de Tokens Gerada: ";
	for( i = tokensSaida.begin(); i != tokensSaida.end(); ++i)
						cout << *i << " - ";
					cout << endl;


	list<string>	tokensSaidaValidado;
	tokensSaidaValidado = validaTokens(tokensSaida, numVirgulas);




	return tokensSaida;
}

Operacao Montador::pegaPredicado(list<string> tokens) throw (runtime_error) {
	ItemOperacao op = encontraOperacao(tokens.front());

	switch (op.tipo) {
	case FR:
		return OperacaoBinaria(tokens);
		//	case R:
		//		return OperacaoBinaria(tokens);
		//	case I:
		//	case J:
		//	case LABEL:
	default:
		throw runtime_error("Operação não identificada");
	}
}

list<string> Montador::validaTokens(list<string> listaTokens, int numVirgulas) throw (runtime_error) {

	ItemOperacao op = encontraOperacao(listaTokens.front());
	switch (op.tipo) {
		case FR:
			if (numVirgulas != 2)
				throw runtime_error("Problema no numero de virgulas " + numVirgulas);
			if (listaTokens.empty())
					throw runtime_error("Lista de tokens vazia - OperacaoBinaria");
			if (listaTokens.size() != 4){
					stringstream num;
					num << listaTokens.size();
					throw runtime_error("Operação binaria com numero errado de argumentos, esperava 4 mas tem " + num.str());
			}
		break;
		//	case R:
		//	case I:
		//	case J:

		default:
			throw runtime_error("operação não identificada");
		}

	return listaTokens;
}

